
layout(quads,fractional_even_spacing) in;


out vec3 tes_pw;
out vec3 tes_normal;

void main(){
    
    //x,y will range 0...1 depending on where we are
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;
    
    //gl_in[].gl_Position holds the 16 control points
    
    vec4 U = vec4( u*u*u, u*u, u, 1 );
    vec4 V = vec4( v*v*v, v*v, v, 1 );
    
    vec4 U_ = vec4( 3*u*u, 2*u, 1, 0 );
    vec4 V_ = vec4( 3*v*v, 2*v, 1, 0 );
     
    //GLSL uses column major order for mat4()
    mat4 MT = mat4( 
        -1,3,-3,1,
        3,-6,3,0,
        -3,3,0,0,
        1,0,0,0
    );
    mat4 M = transpose(MT);
    
    //transposed!
    mat4 Px = mat4(
            gl_in[0].gl_Position.x,gl_in[4].gl_Position.x,gl_in[8].gl_Position.x,gl_in[12].gl_Position.x,
            gl_in[1].gl_Position.x,gl_in[5].gl_Position.x,gl_in[9].gl_Position.x,gl_in[13].gl_Position.x,
            gl_in[2].gl_Position.x,gl_in[6].gl_Position.x,gl_in[10].gl_Position.x,gl_in[14].gl_Position.x,
            gl_in[3].gl_Position.x,gl_in[7].gl_Position.x,gl_in[11].gl_Position.x,gl_in[15].gl_Position.x 
    );
    mat4 Py = mat4(
            gl_in[0].gl_Position.y,gl_in[4].gl_Position.y,gl_in[8].gl_Position.y,gl_in[12].gl_Position.y,
            gl_in[1].gl_Position.y,gl_in[5].gl_Position.y,gl_in[9].gl_Position.y,gl_in[13].gl_Position.y,
            gl_in[2].gl_Position.y,gl_in[6].gl_Position.y,gl_in[10].gl_Position.y,gl_in[14].gl_Position.y,
            gl_in[3].gl_Position.y,gl_in[7].gl_Position.y,gl_in[11].gl_Position.y,gl_in[15].gl_Position.y 
    );
    mat4 Pz = mat4(
            gl_in[0].gl_Position.z,gl_in[4].gl_Position.z,gl_in[8].gl_Position.z,gl_in[12].gl_Position.z,
            gl_in[1].gl_Position.z,gl_in[5].gl_Position.z,gl_in[9].gl_Position.z,gl_in[13].gl_Position.z,
            gl_in[2].gl_Position.z,gl_in[6].gl_Position.z,gl_in[10].gl_Position.z,gl_in[14].gl_Position.z,
            gl_in[3].gl_Position.z,gl_in[7].gl_Position.z,gl_in[11].gl_Position.z,gl_in[15].gl_Position.z 
    );
    
            

    float x = dot(U*M*Px*MT,V);
    float y = dot(U*M*Py*MT,V);
    float z = dot(U*M*Pz*MT,V);
     
    vec4 p = vec4(x,y,z,1.0);
    
    
    //We could compute the normals in the TCS instead of the TES and interpolate them
    //This would be more efficient
 
    x = dot(U_*M*Px*MT,V);
    y = dot(U_*M*Py*MT,V);
    z = dot(U_*M*Pz*MT,V);
    vec3 tangent = vec3(x,y,z);
    
    x = dot(U*M*Px*MT,V_);
    y = dot(U*M*Py*MT,V_);
    z = dot(U*M*Pz*MT,V_);
    vec3 bitangent = vec3(x,y,z);
    
    vec3 normal = cross(tangent,bitangent);
    
    p = p * worldMatrix;
    tes_pw = p.xyz;
    tes_normal = (vec4(normal,0.0) * worldMatrix).xyz;
    
    p = p * viewMatrix;
    p = p * projMatrix;
    gl_Position = p;
}
