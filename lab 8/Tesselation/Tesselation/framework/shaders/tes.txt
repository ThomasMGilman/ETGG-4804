


vec3 interpolate(float u, float v, float w, vec3 a, vec3 b, vec3 c ){
	//simple barycentric interpolation
	vec3 p0 = u * a;
	vec3 p1 = v * b;
	vec3 p2 = w * c;
	return (p0+p1+p2);
}

vec2 interpolate(float u, float v, float w, vec2 a, vec2 b, vec2 c ){
	vec2 p0 = u * a;
	vec2 p1 = v * b;
	vec2 p2 = w * c;
	return (p0+p1+p2);
}

layout(triangles) in;

in vec3 tcs_position[];
in vec3 tcs_normal[];
in vec2 tcs_texCoord[];

out vec3 tes_worldPos;
out vec2 tes_texCoord;
out vec3 tes_normal;

vec3 project( vec3 v, vec3 n, vec3 p ){
	//project p to plane defined by point v and normal n
	vec4 planeEquation = vec4(n, -dot(v,n) );
	float pdistance = dot( vec4(p,1),planeEquation );
	return p - pdistance * n;
}


void main(){
    vec3 p1 = interpolate(
		gl_TessCoord[0], gl_TessCoord[1], gl_TessCoord[2],
		tcs_position[0], tcs_position[1], tcs_position[2] );
	vec3 pr1 = project( tcs_position[0], tcs_normal[0], p1 );
	vec3 pr2 = project( tcs_position[1], tcs_normal[1], p1 );
	vec3 pr3 = project( tcs_position[2], tcs_normal[2], p1 );
	vec3 p1a = interpolate(
		gl_TessCoord[0], gl_TessCoord[1], gl_TessCoord[2],
		pr1,pr2,pr3 );
	float alpha=0.75;
	p1 = (1.0-alpha)*p1 + alpha * p1a;

	p1 = normalize(p1);
	vec3 n1 = p1;
	tes_texCoord = interpolate(gl_TessCoord[0], gl_TessCoord[1],
	gl_TessCoord[2],
	tcs_texCoord[0], tcs_texCoord[1], tcs_texCoord[2] );

     
    vec4 p = vec4(p1,1.0);
	p = p * worldMatrix;
	tes_worldPos = p.xyz;
	p = p * viewMatrix;
	p = p * projMatrix;
	gl_Position = p;
	vec4 n = vec4(n1,0.0);
	n = n * worldMatrix;
	tes_normal = n.xyz;

}
