//layout(isolines) in;	//isolines = generate Line segments
layout(triangles) in;

in vec3 tcs_position[];
in vec3 tcs_normal[];
in vec2 tcs_texCoord[];

out float tes_shaftPct;
out vec3 tes_worldPos;
out vec3 tes_normal;
out vec2 tes_texCoord;

//Wang hash
uint hash(uint v){
	v = 9*( (v >> 16 ) ^ (v ^ 61));
	v ^= (v>>4);
	v = v * 668265261;
	return v ^ (v>>15);
}

uint state;
float xorshift(){
	state = state ^ (state << 13);
	state = state ^ (state >> 17);
	state = state ^ (state << 15);
	return float(state & 0x7fffffff) / float(0x7fffffff);
}

void xorshiftInit(uint v){
	state = gl_PrimitiveID ^ (v<<16);
	state = hash(state);
}

//Barycentric Interpolation
vec3 interpolate(float u, float v, float w, vec3 a, vec3 b, vec3 c ){
	vec3 p0 = u * a;
	vec3 p1 = v * b;
	vec3 p2 = w * c;
	return (p0+p1+p2);
}

vec2 interpolate(float u, float v, float w, vec2 a, vec2 b, vec2 c ){
	vec2 p0 = u * a;
	vec2 p1 = v * b;
	vec2 p2 = w * c;
	return (p0+p1+p2);
}

vec3 project( vec3 v, vec3 n, vec3 p ){
	//project p to plane defined by point v and normal n
	vec4 planeEquation = vec4(n, -dot(v,n) );
	float pdistance = dot( vec4(p,1),planeEquation );
	return p - pdistance * n;
}


void main(){
	////////////////////////////////////////////////INITIALIZE VARIABLES
	tes_shaftPct = gl_TessCoord[0];											//value in range [0-1], first shaft is zero
	float shaftAmount = tes_shaftPct * 20;
	uint shaftNumber = uint(gl_TessCoord[1] * gl_TessLevelOuter[0]);		//multiply coord with number of shafts
	xorshiftInit(shaftNumber);

	////////////////////////////////////////////////GENERATE BARYCENTRIC COORDS
	float u = xorshift();
	float v = xorshift();
	if( u+v > 1.0 ){
		u = 1-u;
		v = 1-v;
	}
	float w = 1.0-u-v;


	////////////////////////////////////////////////SET VARIALBES TO PASS TO FS
	//Position of shaft or point
	vec3 basePos = interpolate(gl_TessCoord[0], gl_TessCoord[1], gl_TessCoord[2], tcs_position[0], tcs_position[1], tcs_position[2]);
	vec3 pr1 = project( tcs_position[0], tcs_normal[0], basePos );
	vec3 pr2 = project( tcs_position[1], tcs_normal[1], basePos );
	vec3 pr3 = project( tcs_position[2], tcs_normal[2], basePos );
	vec3 basePosAlpha = interpolate(gl_TessCoord[0], gl_TessCoord[1], gl_TessCoord[2], pr1, pr2, pr3 );
	float alpha = 0.75;

	//Normal
	vec3 N = normalize(basePos); //interpolate(gl_TessCoord[0], gl_TessCoord[1], gl_TessCoord[2], tcs_normal[0], tcs_normal[1], tcs_normal[2]);

	//set Texture position
	tes_texCoord = interpolate(gl_TessCoord[0], gl_TessCoord[1], gl_TessCoord[2], tcs_texCoord[0], tcs_texCoord[1], tcs_texCoord[2]);


	vec3 p1 = (1.0 - alpha)*basePos + alpha * basePosAlpha + tes_shaftPct * 0.35 * N;
	p1 += vec3(0, -.0005, 0) * shaftAmount * shaftAmount;

	vec4 p = vec4(p1,1.0);
	p *= worldMatrix;
	tes_worldPos = p.xyz;		//set worldPos

	p *= viewMatrix;
	p *= projMatrix;
	gl_Position = p;			//set glPosition

	vec4 n = vec4(N, 0.0);		//set TesNormal
	n *= worldMatrix;
	tes_normal = n.xyz;
}